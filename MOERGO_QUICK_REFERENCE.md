# MoErgo-SC/ZMK: Quick Reference - Protoc/Nanopb & Build System

## ONE-PAGE ARCHITECTURE SUMMARY

### How MoErgo's Nix Build Works

```
nix-build default.nix
    ↓
Loads pinned nixpkgs (nixos-22.05)
    ↓
Evaluates zmk.nix
    ├─ Dependencies: cmake, ninja, gcc-arm-embedded, dtc, python
    ├─ Zephyr modules: cmsis, hal_nordic, tinycrypt, lvgl, picolibc, segger, cirque-input-module
    └─ Via zephyr.nix: reads manifest.json
        ├─ Fetches each module with git + sha256 verification
        ├─ Creates symlink indirection
        └─ Returns module paths for CMake
    ↓
CMake finds protoc in nanopb module (no separate binary)
    ↓
ZMK's CMakeLists.txt runs nanopb_generate_cpp()
    ├─ Condition: CONFIG_ZMK_STUDIO_RPC enabled
    ├─ Input: .proto files from zmk-studio-messages module
    ├─ Output: Generated C++ proto code
    └─ Config: NANOPB_GENERATE_CPP_STANDALONE OFF
    ↓
Compiled into final firmware
```

---

## MANIFEST STRUCTURE

### Key Dependencies (manifest.json):

1. **Zephyr** - Main OS framework
2. **Nanopb** - Custom ZMK fork for proto code generation
   - URL: https://github.com/zmkfirmware/nanopb
   - Revision: 8c60555d...
   - Path: modules/lib/nanopb
   - **Includes protoc binary**
3. **ZMK Studio Messages** - Proto definitions
   - URL: https://github.com/zmkfirmware/zmk-studio-messages
   - Path: modules/msgs/zmk-studio-messages
4. **Other modules** - HAL, libraries, bootloader, etc.

---

## CRITICAL BUILD FILES

### nix/zmk.nix
- Main ZMK derivation
- Specifies: cmake flags, dependencies, build process
- Line 110: Native inputs (cmake, ninja, python, dtc, gcc-arm-embedded)
- Line 111: Build inputs (zephyr module)
- Lines 49-56: Required modules list (nanopb comes via Zephyr)

### nix/zephyr.nix
- Creates module derivations from manifest.json
- Fetches git repos with sha256 verification
- No compilation, only structure creation
- Returns modules via passthru

### nix/manifest.json
- Frozen dependency list
- Each entry has: name, url, revision, sha256, path
- Generated by: `nix/update-manifest` tool

### app/CMakeLists.txt
- Lines 112-125: Nanopb configuration
- Condition: CONFIG_ZMK_STUDIO_RPC
- Key: NANOPB_GENERATE_CPP_STANDALONE OFF
- Input: Proto files from zmk-studio-messages
- Output: C++ code compiled into firmware

---

## HOW PROTOC IS PROVIDED

### Standard Approach:
1. Install protoc system-wide
2. Hope version matches Zephyr's expectations
3. Hope binary works on your architecture

### MoErgo's Approach:
1. Protoc is in nanopb module (source form)
2. Zephyr's nanopb CMake module finds it
3. Everything pinned to exact commit
4. Reproducible across machines

**Result:** No patchelf needed, no binary compatibility issues

---

## CI/BUILD WORKFLOWS

### Primary: .github/workflows/nix-build.yml
```yaml
- Install Nix (cachix)
- nix-build -A glove80_combined -o combined
- nix-build -A go60_combined -o combined
- Upload .uf2 files as artifacts
```
**Status:** ACTIVE - primary build method

### Secondary: .github/workflows/build-container.yml
```yaml
- nix-build release.nix -A lambdaImage
- Convert to OCI image
- Push to Amazon ECR
- Lambda compilation service
```
**Status:** ACTIVE - container builds

### Tertiary: .github/workflows/build.yml
```yaml
- west init -l app
- west update
- west build -s app -p -b <board>
```
**Status:** DISABLED (if: ${{ false }}) - kept for reference

---

## MODULE DEPENDENCY RESOLUTION

### Architecture:
```
zephyr.nix reads manifest.json
    ↓
For each module:
    ├─ fetchgit(url, rev, sha256) → immutable source
    ├─ Create derivation with no compilation
    ├─ Install to $out/<moduleName>
    └─ Export modulePath symlink
    ↓
zmk.nix receives modules
    ↓
Pass to CMake as -DZEPHYR_MODULES=path1;path2;path3
```

### Special Case: Nanopb
- Nanopb is in manifest.json
- Fetched like any other module
- CMake finds it at ${ZEPHYR_BASE}/modules/nanopb
- No special handling needed

---

## BUILD CUSTOMIZATION

### Targets (default.nix):
```nix
glove80_left = zmk.override { board = "glove80_lh"; };
glove80_right = zmk.override { board = "glove80_rh"; };
glove80_combined = combine_uf2 glove80_left glove80_right;

go60_left = zmk.override { board = "go60_lh"; };
go60_right = zmk.override { board = "go60_rh"; };
go60_combined = combine_uf2 go60_left go60_right;
```

### Override Parameters (zmk.nix):
```nix
zmk.override {
  board = "glove80_lh";
  shield = null;                    # Optional shield
  keymap = null;                    # Optional keymap file
  kconfig = null;                   # Optional kconfig overrides
  extraModules = [];                # Extra modules
  snippets = [];                    # Code snippets
}
```

---

## REPRODUCIBILITY GUARANTEES

### What's Pinned:
1. Nixpkgs version (NixOS 25.05 pre-716127)
2. All module git revisions
3. All sha256 hashes for git fetches
4. cmake flags and build configuration
5. gcc-arm-embedded version
6. Python dependencies

### What's NOT Pinned:
- User's local customizations
- System timezone/locale
- Build machine hardware (but binaries are compatible)

### Result:
Same git commit → Identical firmware binary
(Reproducible build!)

---

## ENVIRONMENT CHARACTERISTICS

### Isolated from System:
- No /usr/bin dependencies
- No system gcc/python/cmake
- All tools from nixpkgs
- Build in temporary nix sandbox

### Advantages:
- Works on any Linux/macOS (with Nix installed)
- No "works on my machine" problems
- CI environment identical to local
- Easy updates to toolchain versions

---

## UPDATING DEPENDENCIES

### Process:
```bash
# In ZMK root directory
nix shell -f . west -c west init -l app
nix shell -f . west -c west update
nix shell -f . update-manifest -c update-manifest > nix/manifest.json
```

This:
1. Fetches latest west dependencies
2. Runs `west update` to get new module versions
3. Freezes manifest with nix-prefetch-git
4. Generates new sha256 hashes
5. Writes to manifest.json

---

## KEY DIFFERENCES FROM STANDARD ZMK

| Aspect | Standard ZMK | MoErgo ZMK |
|--------|--------------|-----------|
| **Initialization** | `west init` | manifest.json |
| **Module fetching** | Dynamic (`west update`) | Pre-computed (Nix) |
| **Toolchain** | System-wide | Isolated (Nix) |
| **Protoc** | System or bundled | Via nanopb module |
| **Reproducibility** | Machine-dependent | Guaranteed |
| **Binary patching** | May be needed | Never needed |
| **Build command** | `west build` | `nix-build` |
| **CI caching** | Minimal | Cachix (fast) |

---

## PROTOC/NANOPB SPECIFIC POINTS

### How Protoc is Found:
1. CMakeLists.txt loads nanopb.cmake from nanopb module
2. nanopb.cmake defines nanopb_generate_cpp() function
3. Function uses find_program(protoc) or similar
4. Protoc is in nanopb module's source or build

### Proto Files Used:
- studio.proto
- meta.proto
- core.proto
- behaviors.proto
- keymap.proto

All from: `modules/msgs/zmk-studio-messages`

### Generated Code Location:
- `${CMAKE_CURRENT_BINARY_DIR}` (build directory)
- Included in compilation via `target_include_directories()`
- Source files added via `target_sources()`

### Conditions:
- Only compiled if `CONFIG_ZMK_STUDIO_RPC=y`
- Default: disabled (firmware works without)
- When enabled: adds studio RPC protocol support

---

## TROUBLESHOOTING LOGIC

### "protoc not found"
- Check: Is nanopb in manifest.json? ✓
- Check: Is zephyr.nix fetching it? ✓
- Check: Is CMake finding it? Check CMAKE_MODULE_PATH
- Solution: Rebuild with `nix-build --no-cache`

### "Wrong protoc version"
- Standard ZMK: Could be system protoc
- MoErgo: Pinned to nanopb module revision
- Solution: Update manifest.json with `update-manifest`

### "Binary compatibility error"
- Standard ZMK: Possible (cross-compilation, different libc)
- MoErgo: Nix handles this transparently
- Solution: Nix solves it automatically

### "Nix build takes forever"
- First build: Yes, compiles everything
- Subsequent builds: Cachix caches dependencies
- Solution: Use `cachix use moergo-glove80-zmk-dev`


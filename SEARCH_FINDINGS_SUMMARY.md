# MoErgo-SC/ZMK Repository Search Results - Complete Summary

**Search Date:** 2026-02-21  
**Repository:** https://github.com/moergo-sc/zmk  
**Focus:** Protoc/Nanopb handling in Nix build system

---

## FINDINGS

### 1. Protoc/Nanopb Binary Handling in Nix Build

**Result:** NO special handling (patchelf, fixup, or binary patching)

**Why:**
- Protoc is not a separate binary dependency
- Protoc comes as part of the nanopb module source
- Nanopb is fetched via git as a module (like all other modules)
- Located at: `modules/lib/nanopb`
- CMake module finds protoc automatically when nanopb.cmake is included

**In manifest.json:**
```json
{
  "name": "nanopb",
  "url": "https://github.com/zmkfirmware/nanopb",
  "revision": "8c60555d6277a0360c876bd85d491fc4fb0cd74a",
  "path": "modules/lib/nanopb",
  "sha256": "1w77q47cvhg7xmfzbws4w2pn1zr74vh9lyzj0cf1p8gz0n2l3q1g"
}
```

---

### 2. CI/Workflow Files Configuration

**Primary CI Workflow:** `.github/workflows/nix-build.yml` (ACTIVE)

```yaml
Steps:
  1. Install Nix + cachix
  2. nix-build -A glove80_combined -o combined
  3. nix-build -A go60_combined -o combined
  4. Upload .uf2 artifacts
```

**Key Points:**
- Uses Nix as primary build method
- Cachix caches compiled dependencies for speed
- No west initialization needed
- No protoc installation step

**Secondary CI:** `.github/workflows/build-container.yml` (ACTIVE)
- Builds Lambda container with OCI image
- Includes full build environment
- Pushes to Amazon ECR

**Reference CI:** `.github/workflows/build.yml` (DISABLED)
- Original west-based build method
- Kept for reference only
- Status: `if: ${{ false }}`

---

### 3. Special Provisions/Patches for Nanopb

**File:** `nix/west-manifest.patch`

**Purpose:** Patches west.py to allow exporting frozen manifest for Nix

**What it does:**
```patch
Allows projects to be in manifest freeze even if not yet cloned
This enables Nix's update-manifest tool to work with frozen manifests
```

**Why needed:**
- Nix uses `west manifest --freeze` to get all revisions
- Standard west errors if a project isn't cloned
- Patch allows freeze to work pre-clone

**For nanopb specifically:**
- No specific nanopb patches found
- Uses standard ZMK fork of nanopb (github.com/zmkfirmware/nanopb)
- Pinned to specific commit via manifest

---

### 4. Setup Files - Nix Configuration

**Primary Files:**

1. **default.nix** - Entry point
   - Defines build targets (glove80_left, go60_right, etc.)
   - Uses newScope pattern from nixpkgs

2. **nix/pinned-nixpkgs.nix** - Environment setup
   - Fetches frozen nixpkgs version
   - Reads: nix/pinned-nixpkgs.json
   - Version: NixOS 25.05 pre-716127

3. **nix/zmk.nix** - ZMK derivation (PRIMARY)
   - Line 110-111: Dependencies (cmake, ninja, gcc-arm-embedded, dtc, python)
   - Line 49-56: Module dependencies
   - Line 89-108: CMake flags
   - Passes -DZEPHYR_MODULES with all module paths

4. **nix/zephyr.nix** - Module builder
   - Reads manifest.json
   - Fetches each module via git + sha256 verification
   - Creates symlink indirection for module paths
   - Returns modules to zmk.nix

5. **nix/manifest.json** - Dependency manifest
   - Frozen list of all modules
   - Each has: name, url, revision, sha256, path
   - 30+ modules including nanopb, zmk-studio-messages
   - Generated by: `nix/update-manifest` tool

**Secondary Files:**

6. **release.nix** - Lambda/container builds
   - Builds OCI image with compilation service
   - Includes all dependencies as layers
   - Pre-compiles with ccache for speed

7. **nix/west-shell.nix** - Development environment
   - For `west init` and `west update` commands
   - Includes west, python dependencies

8. **nix/cmake-shell.nix** - CMake development shell
   - For running cmake directly
   - Pre-sets CMake environment variables

---

### 5. Documentation About Nix Building

**File:** `README-NIX.md`

**Content:**
- How to build with nix-build
- Examples: `nix-build -A glove80_left -o left`
- How to combine left + right: `nix-build -A glove80_combined`
- How to add new targets
- Notes that west is not needed with Nix

**Key Quote:**
> "Nix makes setup significantly easier. With this approach `west` is not needed."

---

## SPECIAL NANOPB MODULE HANDLING

### In manifest.json:
- Custom ZMK fork: https://github.com/zmkfirmware/nanopb
- Not standard nanopb, but adapted for ZMK

### In nix/zephyr.nix:
```nix
mkModule = { name, revision, url, sha256, ... }:
  stdenvNoCC.mkDerivation (finalAttrs: {
    name = "zmk-module-${name}";
    src = fetchgit { inherit name url sha256; rev = revision; };
    # ... no compilation, just structure ...
    installPhase = ''
      mkdir $out
      ln -s ${finalAttrs.src} $out/${name}
    '';
  });
```

**Process:**
1. Git fetches nanopb with sha256 verification
2. Creates minimal derivation (no compilation)
3. Returns module path to CMake

### In app/CMakeLists.txt (Lines 112-125):
```cmake
if (CONFIG_ZMK_STUDIO_RPC)
  list(APPEND CMAKE_MODULE_PATH ${ZEPHYR_BASE}/modules/nanopb)
  include(nanopb)
  set(NANOPB_GENERATE_CPP_STANDALONE OFF)
  
  nanopb_generate_cpp(proto_srcs proto_hdrs RELPATH ...
    ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/studio.proto
    ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/meta.proto
    ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/core.proto
    ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/behaviors.proto
    ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/keymap.proto
  )
  
  target_include_directories(app PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
  target_sources(app PRIVATE ${proto_srcs} ${proto_hdrs})
  add_subdirectory(src/studio)
endif()
```

**Critical Config:** `NANOPB_GENERATE_CPP_STANDALONE OFF`
- Uses Zephyr's nanopb integration
- Not standalone mode

---

## HOW THEIR BUILD IS DIFFERENT FROM STANDARD ZMK

### Standard ZMK:
1. Run `west init -l app`
2. Run `west update` (fetches modules dynamically)
3. Run `west build -b <board>`
4. System protoc used (may vary)
5. System cmake/ninja used
6. Build reproducibility depends on system state

### MoErgo-SC ZMK:
1. manifest.json pre-computed (all modules + sha256)
2. No west init needed
3. Run `nix-build -A <target>`
4. Protoc from pinned nanopb module
5. Everything from nixpkgs (pinned version)
6. Guaranteed reproducible builds

### Protoc/Nanopb Specific Differences:
- **Standard:** Protoc might come from system PATH, west tools, or separate package
- **MoErgo:** Protoc is part of nanopb module (no separate installation)
- **Standard:** Version mismatch possible between system protoc and Zephyr's expectations
- **MoErgo:** All versions pinned to exact commits
- **Standard:** Binary compatibility issues possible
- **MoErgo:** Nix handles binary compatibility automatically

---

## NO PATCHELF NEEDED

**Search Result:** No references to patchelf, fixup, or RPATH modifications

**Why it's not needed:**
1. Protoc is not a separate binary
2. Nanopb module handles protoc internally
3. CMake finds everything via CMAKE_MODULE_PATH
4. Nix's stdenv handles all library dependencies
5. No cross-compilation patching needed

**If protoc WERE separate binary:**
- Nix would use patchelf automatically in the derivation
- MoErgo doesn't need this because protoc is source-based

---

## MANIFEST FETCHING MECHANISM

### How Dependencies Are Frozen:

1. **Initial Setup:**
   ```bash
   nix shell -f . west
   west init -l app
   west update
   ```

2. **Generate Manifest:**
   ```bash
   nix shell -f . update-manifest
   update-manifest > nix/manifest.json
   ```

3. **What update-manifest does:**
   - Runs `west manifest --freeze`
   - Converts YAML to JSON
   - For each module: runs `nix-prefetch-git`
   - Generates sha256 hash for each commit
   - Outputs frozen JSON manifest

4. **Result:** manifest.json
   - All modules pinned to exact commits
   - All commits have sha256 hashes
   - No network calls at build time
   - Deterministic, reproducible

---

## BUILD ENVIRONMENT SETUP

### Nixpkgs Version:
```json
{
  "url": "https://releases.nixos.org/nixpkgs/nixpkgs-25.05pre716127.566e53c2ad75/nixexprs.tar.xz",
  "sha256": "182d5xq2w70znk61b8bn0cyq4jmp7vw239vmxbmsvv13zrjainbv"
}
```

**Version:** NixOS 25.05 pre-release (very recent as of Feb 2026)

### Dependencies Included:
- cmake (Nix package)
- ninja (Nix package)
- dtc (device tree compiler, Nix package)
- gcc-arm-embedded (ARM toolchain, Nix package)
- python3 with packages:
  - pyelftools
  - pyyaml
  - canopen
  - packaging
  - progress
  - anytree
  - intelhex
  - pykwalify

### Not Included (by design):
- System gcc, python, cmake
- System libraries
- Any /usr dependencies

---

## CI BUILD ENVIRONMENT DIFFERENCES

### GitHub Actions nix-build.yml:
```yaml
- uses: cachix/install-nix-action@v27
  with:
    nix_path: nixpkgs=channel:nixos-22.05
```

**Note:** Uses nixos-22.05 channel, but also loads pinned-nixpkgs.nix which overrides with specific version

### Cachix Caching:
```yaml
- uses: cachix/cachix-action@v15
  with:
    name: moergo-glove80-zmk-dev
    authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"
```

**Effect:**
- Pre-built binaries cached in moergo-glove80-zmk-dev cache
- Subsequent builds skip compilation if binary cache hit
- Dramatically faster CI builds
- Public cache (anyone can use it)

### Lambda Container Builds:
- Uses release.nix to build OCI image
- Bundles all dependencies as layers
- Pre-compiles with ccache
- Pushes to Amazon ECR
- Used for backend compilation service

---

## REPRODUCIBILITY GUARANTEES

### Fully Pinned:
1. Nixpkgs version - exact
2. All module commits - exact
3. All module sha256 - verified
4. cmake flags - identical
5. gcc-arm-embedded version - identical
6. Python dependencies - identical

### Result:
- Same git commit → identical firmware binary
- Build on any machine → same result
- CI and local builds → identical
- Reproducible firmware releases

### Not Pinned (allowed to vary):
- Build machine CPU
- Build machine memory
- Build timestamp (not included in binary)
- User's locale/timezone

---

## KEY ARCHITECTURAL INSIGHTS

### 1. Determinism by Default
- Not opt-in, built into the design
- manifest.json is the single source of truth
- All versions frozen at commit time

### 2. No Toolchain Installation
- No "install protoc" step
- No "apt-get install cmake" step
- Everything declared in Nix
- Reproducible across machines

### 3. Protoc Integration
- Minimal - just loads nanopb module
- No custom wrapper or adapter
- Zephyr's nanopb CMake module handles it
- Same as using Zephyr with protoc

### 4. CI/CD Acceleration
- Cachix caches compiled dependencies
- First build: slow (compiles everything)
- Subsequent builds: fast (binary cache hits)
- Lambda service: pre-compiled images

### 5. West Still Used (For Updates)
- Not for building (west build never runs in CI)
- Only for updating: `west manifest --freeze`
- Freezes result into manifest.json
- Nix never calls west at build time

---

## FILES CREATED FOR YOUR REFERENCE

Three comprehensive documents have been created in your repository:

1. **MOERGO_BUILD_ANALYSIS.md** (437 lines)
   - Complete architectural analysis
   - 12 sections covering all aspects
   - Detailed code examples
   - Build chain explanation
   - Reproducibility details

2. **MOERGO_QUICK_REFERENCE.md** (320 lines)
   - One-page architecture summary
   - Build workflow diagram
   - Manifest structure
   - CI workflows
   - Troubleshooting guide
   - Key differences table

3. **MOERGO_FILE_LOCATIONS.md** (400 lines)
   - Complete project structure
   - File relationships diagram
   - Key files and roles
   - Modification guide
   - Complete build flow
   - Lambda container details

---

## ANSWERS TO ORIGINAL QUESTIONS

### 1. How they handle protoc/nanopb binary in Nix build?
**Answer:** Not as a separate binary. Protoc is part of the nanopb module source, fetched like any other module with git+sha256 verification. No patchelf or binary patching needed.

### 2. CI/workflow files setup?
**Answer:** Primary nix-build.yml uses `nix-build -A <target>`. Secondary build-container.yml builds Lambda image. Original build.yml (west-based) is disabled.

### 3. Special provisions/patches for nanopb?
**Answer:** No nanopb-specific patches. Only west-manifest.patch to allow frozen manifest export for Nix. Uses custom ZMK fork of nanopb.

### 4. Setup files (setup.nix, shell.nix, flake.nix)?
**Answer:** default.nix (main entry), nix/zmk.nix (build rules), nix/zephyr.nix (modules), nix/west-shell.nix (dev), nix/cmake-shell.nix (dev). No flake.nix.

### 5. Documentation about building with Nix?
**Answer:** README-NIX.md with examples. Good coverage of basic usage but limited architectural details (now provided in your analysis documents).

---

## BUILD CHAIN COMPLETE PICTURE

```
User: nix-build default.nix -A glove80_combined
    ↓
[default.nix] Defines targets
    ↓
[zmk.nix] Specifies dependencies + CMake flags
    ├─ cmake, ninja, gcc-arm-embedded, dtc, python
    └─ zephyr module (with all modules)
    ↓
[zephyr.nix] Creates modules from manifest
    ├─ Reads: manifest.json
    ├─ Fetches: nanopb @ 8c60555d...
    ├─ Fetches: zmk-studio-messages
    └─ Fetches: All other modules
    ↓
[CMakeLists.txt] Builds firmware
    ├─ Line 112: Appends nanopb to CMAKE_MODULE_PATH
    ├─ Line 114: Loads nanopb.cmake
    ├─ Line 117: Calls nanopb_generate_cpp()
    ├─ Protoc: Found in nanopb module
    ├─ Proto files: From zmk-studio-messages
    └─ Output: Generated C++ code
    ↓
[Compilation]
    ├─ Compiles proto-generated code
    ├─ Links with firmware
    └─ Produces: zmk.uf2
    ↓
[combine_uf2] Combines left + right
    └─ Output: glove80.uf2 or go60.uf2
```

All paths deterministic, all versions pinned, all hashes verified.

